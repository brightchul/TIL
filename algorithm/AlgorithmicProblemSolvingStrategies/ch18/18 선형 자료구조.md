# 18 선형 자료구조

## 18.2 동적 배열

배열의 큰 문제 중 하나는 배열의 크기를 지정해야 한다는 점이다. 이것을 해결하기  위해 동적 배열이 고안되었다. 동적배열은 별도의 자료구조이다.

#### 배열의 특성

- 원소들은 메모리의 연속된 위치에 저장된다.
- 주어진 위치의 원소를 반환하거나 변경하는 동작은 O(1)에 할 수 있다.

#### 동적 배열의 특성 (배열 특성에 추가로 가진다.)

- 배열의 크기를 변경하는 resize() 연산이 가능하다. 배열의 크기에 비례하는 수행시간이 걸린다.
- 주어진 원소를 배열의 맨 끝에 추가함으로서 크기를 1늘리는 append() 연산을 지원한다. 이 동작을 수행하는데 상수 시간이 걸린다.

동적 배열은 크기가 바뀌어야 할때 새 배열을 동적 할당 받은뒤, 기존 원소들을 복사하고 새 배열을 참조하도록 바꿔치기 한다. 이 때 복사시간은 배열의 크기에 비례한다. append()를 상수시간에 구현하기 위해서 여유분의 메모리를 미리 할당받아 둔다.

문제는 미리 할당해둔 메모리가 다 찼을 때는 아래처럼 새로운 배열을 할당하고 복사한다.

```c++
// 배열 용량이 꽉 찼으면 재할당받는다.
if(size == capacity) {
    int newCapacity = capacity + M;
    int* newArray = new int[newCapacity];
    // 기존의 자료를 복사한다.
    for(int i=0; i<size; ++i)
        newArray[i] = array[i];
    // 기존의 배열을 삭제하고, 새 배열로 바꿔치기 한다.
    if(array) delete[] array;
    array = newArray;
    capacity = newCapacity;
}
// 배열 끝에 원소를 삽입한다.
arrya[size++] = newValue;
```

이러한 재할당 과정에 드는 시간은 O(N+M)이 된다. append()를 여러번 하다보면 선형 시간이 걸리는 append() 연산이 있게 된다.



### 동적 배열의 재할당 전략

호출할 때마다 수행 시간이 달라지는 함수의 시간 복잡도를 계산하는 한 가지 방법은 , 연산을 아주 여러 번 반복해서 수행후, 각 수행 시간의 평균을 내는 것이다. 

배열 용량을 M씩 증가시켰다. M의 크기가 증가하면 재할당의 횟수가 줄기는 하지만 M을 단순히 늘린다고 되는 문제가 아니다.  텅 빈 배열에서 N번 append() 연산을 할 때 재할당의 수(K)는 O(N/M) 이며 M은 상수이니 N이 커지면 O(N) 이라 할수 있다. 이 때 복사되는 원소의 수는 M개, 2M개, ... KM개씩 증가하므로 전체 복사되는 원소의 수는 다음과 같다.

![](./1.jpg)

따라서 한 번의 append() 연산에 드는 시간은 평균적으로 O(N^2)/N = O(N)이 된다. 만약 재할당의 크기를 2배씩 올린다면 어떠할까? 이전과 비교했을때 훨씬 줄어든다. 

이런 재할당 전략을 쓸 때 0이상의 i번 재할당 시에 복사하는 원소의 수는 2^i이다. 처음부터K-2번 재할당까지 복사하는 원소의 수의 합은 마지막 K-1번 재할당에서 복사하는 원소의 수와 거의 같다. 마지막 재할당에서 복사하는 원소의 수 2^(k-1)는 O(N)이기 때문에 2번 하더라도 O(N)이 된다. 즉 한 번의 append()에 드는 시간은 평균적으로 O(1)이라 할수 있다.



## 18.3 연결리스트

배열은 원소 삭제, 삽입에 대해서 원소의 개수에 선형 비례하는 시간이 걸리는 데 이러한 문제를 해결하기 위해 고안된 자료구조가 연결 리스트이다.

배열은 메모리의 연속된 위치에 각 원소들이 저장되어 있다면,  연결 리스트(linked list)는 흩어져 있는 원소들이 이전, 다음 원소의 포인터를 가지고 있는 방식으로 구현된다. 원소와 포인터의 집합들을 리스트의 노드(node)라고 부른다. 

```c++
struct ListNode {
    int element;	// 담고 있는 원소
    ListNode *prev, *next;	// 이전, 다음 노드의 포인터
}
```

연결 리스트는 첫 번째 노드와 마지막 노드에 대한 포인터를 각각 머리(head)와 꼬리(tail)이라고 부른다. 대개 연결 리스트는 이와 같이 머리와 꼬리에 대한 포인터만을 가진 클래스로 구현된다.



### 연결 리스트 다루기

연결 리스트에서 i번째 노드를 찾아내려면 리스트의 머리에서부터 시작해 하나씩 포인터를 따라가며 다음 노드를 찾아야한다. 따라서 리스트 길이에 선형 비례하게 된다.

반면 새 노드 삽입, 삭제 작업은 간단하다. 이후, 이전 노드들의 포인터만 바꾸면 된다. 따라서 둘다 상수 시간에 이루어진다.



#### 응용연산 : 삭제했던 원소 돌려놓기

한 번 삭제 했던 원소를 제자리에 쉽게 돌려 놓을 수 있다. 삭제된 노드에 이전, 이후 노드의 포인터가 저장되어 있으므로 원래 리스트에 다시 삽입할 수 있다. 물론 이전, 이후 노드 또한 삭제된 상태에서 수행하면 리스트를 망가뜨리기 때문에 항상 삭제한 순서의 반대로 복구가 이루어질 때만 사용할 수 있다.

```c++
// node 이전/이후 노드의 포인터를 바꿔서 node를 리스트에서 삭제한다.
void deleteNode(ListNode *node) {
    node->prev->next = node->next;
    node->next->prev = node->prev;
}

// node 이전/이후 노드의 포인터를 바꿔서 자기 자신을 다시 리스트에 삽입한다.
void recoverNode(ListNode *node) {
    node->prev->next = node;
    node->next->prev = node;
}
```

이 연산은 프로그램에서 되돌리기(undo) 연산을 지원하는데 쓸수 있고, 11장에서 다루는 조합 탐색에도 유용하다. 조합 탐색에서는 답의 한 조각을 만들고 현재의 상태를 갱신한 뒤 나머지를 재귀 호출로 연결한다. 그리고 재귀 호출이 끝난 후 문제의 상태는 다시 복구되어야 한다. 양방향 연결 리스트로 문제의 현재 상태를 표현하면 되돌리기 연산을 통해 문제의 상태를 되돌리는 작업을 효율적으로 할 수 있다. [[Undo 양방향 연결리스트 자바 코드]](https://gist.github.com/brightchul/dc760d05e05fc88c1084bac0cdf2b3ab)

이 장점을 활용한 기법으로 커누스의 [춤추는 링크들(Danding Links)](https://en.wikipedia.org/wiki/Doubly_linked_list#Deleting_a_node)이 있다. 



## 18.4 동적 배열과 연결 리스트의 비교

| 작업                                   | 동적 배열 | 연결 리스트 |
| -------------------------------------- | --------- | ----------- |
| 이전 원소/다음 원소 찾기               | O(1)      | O(1)        |
| 맨 뒤에 원소 추가/삭제하기             | O(1)      | O(1)        |
| 맨 뒤 이외의 위치에 원소 추가/삭제하기 | O(n)      | O(1)        |
| 임의의 위치에 우너소 찾기              | O(1)      | O(n)        |
| 크기 구하기                            | O(1)      | O(n), O(1)  |



## 18.5 조세푸스 문제

[[문제 내용]](https://algospot.com/judge/problem/read/JOSEPHUS)

이 문제는 연결 리스트로 풀 수 있는 전형적인 문제이다. 원형으로 연결된 연결 리스트 위에서 이번에 죽을 사람을 가리키는 포인터 kill을 유지하면서, 이 포인터가 가리키는 사람을 죽이고 포인터를 K-1번 앞으로 옮기는 방식으로 구현하면 된다. 한 사람 죽을 때마다 포인터를 K-1번 옮기기에 총 시간 복잡도는 O(NK)가 된다. 

표준 라이브러리에서는 원형 연결 리스트를 제공하지 않지만, 포인터를 처음으로 옮겨주는 연산을 통해 원형 리스트를 흉내낼 수 있다. 

```c++
void josephus(int n, int k) {
    // 리스트를 준비한다.
    list<int> survivors;
    for(int i=1; i<=n; i++) survivors.push_back(i);
    // 이번에 죽을 사람을 나타내는 포인터
    list<int>::iterator kill = survivors.begin();
    while(n > 2) {
        kill = survivors.erase(kill);
        if(kill == survivors.end()) kill = survivors.begin();
        --n;	// c++의 리스트는 size가 O(N)이라 n으로 대체함.
        //k-1번 다음 사람으로 옮긴다.
        for(int i=0; i<k-1; ++i) {
            ++kill;
            if(ki;; == survivors.end()) kill = survivors.begin();
        }
    }
    cout << survivors.front() << " " << survivors.back() << endl;
}
```



### 조세푸스 문제  빠르게 풀기

다른 여러 방법이 있는 대표적인 것으로 K-1 포인터를 옮기는 대신 (K - 1) mod N 번 포인터를 옮기는 것이 있다.  N명이 남아 있을 때 N번 포인터를 옮기면 결국 자기 자신으로 돌아오기 때문이다. 이러면 시간 복잡도는 O(NK)대신 O(N^2) 가 된다. K가 클 때 유용하다. 이외에도 O(N)이 걸리는 동적 계획법 등 다양한 방법이 있다.

```java
// (K-1)%N으로 풀기
public static LinkedList run(LinkedList<Integer> list, int k) {
    int k_1 = k-1;
    int idx = 0;

    while(list.size() > 2) {
        list.remove(idx);
        if(idx >= list.size()) idx = 0;

        idx = (idx + k_1) % list.size();
    }
    return list;
}
```

[[전체코드]](https://gist.github.com/brightchul/dda14ee111788f4ff517143dfe9803a7)

























