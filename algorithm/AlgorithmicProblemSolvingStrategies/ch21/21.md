# 21 트리의 구현과 순회

## 21.1 도입

게층적 구조를 갖는 자료들을 표현하기 위한 자료구조를 트리(tree)라고 한다. 어떤 형태로 트리를 구성하느냐, 자료들을 어떻게 배치하느냐에 따라 다야한 형태의 트리가 있을 수 잇으며 ,이들ㅇ르 이용해 다양한 문제를 빠르게 풀 수 있다.



#### 트리의 구성요소

트리는 자료가 저장된 노드(node)들이 간선(edge)으로 서로 연결되어 있다.

두 연결된 노드 중 상위 노드를 부모(parent) 노드, 하위 노드를 자식(child) 노드라고 부른다. 부모 노드와 그의 부모들을 통틀어 선조(ancestor)라고 부르고, 자식 노드와 그의 자식들을 통틀어 자손(descendant)이라고 부른다. 



#### 트리와 노드의 속성

다른 모든 노드들을 자손으로 갖는 단 하나의 노드는 루트(root)라고 한다. 자식이 하나도 없는 노드들을 리프(leaf)라고 부른다. 

루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수를 해당 노드의 깊이(depth)라고 한다. 트리에서 가장 깊숙히 있는 노드의 깊이를 해당 트리의 높이(height)라고 한다. 



#### 트리의 재귀적 속성

트리는 재귀적인 성질을 가지고 있다. 한 노드와 그의 자손들을 모두 모으면 그들도 하나의 트리가 된다. 어떤 노드 t와 그 자손들로 구성된 트리를 `t를 루트로 하는 서브트리(subtree)`라고 한다. 따라서 트리를 다루는 코드들은 보통 재귀 호출을 이용해 구현된다.



#### 트리의 표현

트리는 다양한 방법으로 구현 가능하지만, 가장 일반적인 형태는 각 노드를 하나의 구조체, 객체로 표현하고 이들을 서로의 포인터로 연결한다.

```c++
class TreeNode {
    String label;
    TreeNode parent;
    ArrayList<TreeNode> children;
}
```

트리의 구조나 사용 용도에 따라서 다양한 형태로 구현이 된다. 

이진트리는 오른쪽, 왼쪽에 최대 하나의 자식만 가질 수 있다. 힙은 자리가 비어있지 않고 노드를 채워넣기 때문에 배열을 사용해 트리의 내용을 표현할 수 있다. 상호 배타적 집합 구조에서는 각 노드가 자신의 부모를 가리키는 포인터를 가지고 있으며, 부노는 자식에 대한 정보가 없다.



## 21.2 트리의 순회

자료 구조의 가장 기초적인 연산 중 하나는 포함되어 있는 자료를 전부 순회하는 것이다. 트리는 재귀적 속성을 이용해서 순회를 한다. 모든 트리는 각 자식들을 루트로 하는 서브트리와 루트로 나눌 수 있으므로, 트리의 루트가 주어질 때 루트를 방문한 뒤 각 서브트리를 재귀적을 방문하는 함수를 만들어 트리의 모든 노드를 순회할 수 있다.

```c++
// 주어진 트리의 각 노드에 저장된 값을 모두 출력한다.
public void printLabels(TreeNode root) {
    // 루트에 저장된 값을 출력한다.
    System.out.println(root.label);
    // 각 자손들을 루트로 하는 서브트리에 포함된 값드을 재귀적으로 출력한다.
    for(int i=0; i<root.children.size(); ++i)
        printLabels(root.children.get(i));
}
```



순회의 또 다른 사용 예로 트리의 높이를 구하는 문제가 있다. 서브트리의 개념을 이용하면 트리의 높이 또한 재귀적으로 정의할 수 있기 때문이다. 루트의 각 자식들을 루트로 하는 서브트리들의 높이중 최대치에 1을 더한 값이 전체 트리의 높이이다. 자손이 없는 경우에는 높이가 0인 점을 조심한다.

```java
public int height(TreNode root) {
    int h = 0;
    for(int i=0; i<root.children.size(); i++)
        h = Math.max(h, 1+height(root.children.get(i)));
    return h;
}
```





## 21.3 & 21.4 문제 : 트리 순회 순서 변경

#### [[문제내용]](https://algospot.com/judge/problem/read/TRAVERSAL)

### 풀이

재귀 호출을 이용하면 간단하게 구현 가능하다.

> printPostOrder(preorder[], inorder[]) = 트리의 전위 순회 순서 preorder[]와 주위 순회 순서 inorder[]가 주어질 때, 후위 순회 순서를 출력한다.

트리의 루트는 전위 순회에서 가장 먼저 방문하기 때문에 preorder[0]이 루트 번호이다. 이 루트 번호를 inorder[]에서 찾아보면 각 서브트리의 크기를 알 수 있다. 그러면 preorder[]와 inorder[]를 적절히 잘라 왼쪽 서브트리의 방문 순서, 오른쪽 서브트리의 방문 순서를 나눌 수 있다. 그리고 각 서브트리를 후위 순회한 결과를 재귀 호출을 이용해 출력하고, 마지막으로 루트의 번호를 출력하면 된다.

```java
void printPostOrder(List<Integer> preorder, List<Integer> inorder) {
    // 트리에 포함된 노드의 수
    int N = preorder.size();
    // 기저 사례 : 텅 빈 트리면 곧장 종료
    if(preorder.isEmpty()) return;
    // 이 트리의 루트는 전위 탐색 결과로부터 바로 알 수 있다.
    int root = preorder.get(0);
    // 이 트리의 왼쪽 서브트리의 크기는 중위 탐색 결과에서 루트 위치를 찾아서 알 수 있다.
    int L = inorder.indexOf(root);
    // 오른쪽 서브트리의 크기는 N에서 왼쪽 서브트리와 루트를 빼면 알 수 있다.
    int R = N - 1 - L;
    // 왼쪽과 오른쪽 서브트리의 순회 결과를 출력
    printPostOrder(preorder.subList(1, L+1), inorder.subList(0, L) );
    printPostOrder(preorder.subList(L+1, N), inordr.subList(L+1, N));
    // 후위 순회이므로 루트를 가장 마지막에 출력한다.
    System.out.println(root + " ");
}
```