# 프로그래머스 : 최고의 집합

## 문제 설명 [[링크]](https://programmers.co.kr/learn/courses/30/lessons/12938)
자연수 n 개로 이루어진 중복 집합(multi set, 편의상 이후에는 집합으로 통칭) 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다.

1. 각 원소의 합이 S가 되는 수의 집합
2. 위 조건을 만족하면서 각 원소의 곱 이 최대가 되는 집합

예를 들어서 자연수 2개로 이루어진 집합 중 합이 9가 되는 집합은 다음과 같이 4개가 있습니다.
{ 1, 8 }, { 2, 7 }, { 3, 6 }, { 4, 5 }
그중 각 원소의 곱이 최대인 { 4, 5 }가 최고의 집합입니다.

집합의 원소의 개수 n과 모든 원소들의 합 s가 매개변수로 주어질 때, 최고의 집합을 return 하는 solution 함수를 완성해주세요.
```
[제한사항]
- 최고의 집합은 오름차순으로 정렬된 1차원 배열(list, vector) 로 return 해주세요.
- 만약 최고의 집합이 존재하지 않는 경우에 크기가 1인 1차원 배열(list, vector) 에 -1 을 넣어 반환 해주세요.
- 자연수의 개수 n은 1 이상 10,000 이하의 자연수입니다.
- 모든 원소들의 합 s는 1 이상, 100,000,000 이하의 자연수입니다.

[예]
n=2, s=9, return [4,5]
n=2, s=1, return [-1]
n=2, s=8, return [4,4]
```

## 문제 풀이
몇가지 경우를 간단히 적어보면 s/n, (s/n)+1 되는 값들간의 곱이 최대값을 나오게 하는 조합이라는 것을 알수 있다. 그 다음에는 for 루프를 돌면서 하나씩 연산해서 배열에 추가하면 끝이 난다.


## 코드 구현

아래 코드는 s/n를 매회 해주면서 나온 결과값을 s에서 제외하고, n을 감소시킨 다음 계속 그 과정을 반복한다. 
```java
public int[] solution(int n, int s) {
    if(s/n == 0) return new int[]{-1};
    int[] ret = new int[n];

    // 0번째부터 차례대로 넣기 위해 idx 이용함
    for(int i=n, idx=0; i>0; i--) {
        int one = s / i;
        ret[idx++] = one;
        s -= one;
    }
    return ret;
}
```



다른 분이 푼 코드를 봤는데 좋아서 기록한다. 

배열값에 들어가는 최소값은 s/n이므로 최소값으로 배열에 다 채워놓고 시작한다. 만약 s/n의 나머지가 존재할 경우 s/n+1로 만들어주기 위해 나머지가 1씩 분배된다. 오름 차순이기 때문에 맨 뒤부터 하나씩 증가시킨다. 순회는 s%n 즉 n으로 나눈 나머지이기 때문에 전체 길이인 n을 결코 넘지 않는다.  

```java
public int[] solution2(int n, int s) {
    if(s/n == 0) return new int[]{-1};
    int[] ret = new int[n];
    Arrays.fill(ret, s/n);

    // 오름차순으로 만들기 위해 idx을 이용해 맨뒤부터 증가시키며 이동한다.
    for(int i=s%n, idx = n-1; i > 0; i--) {
        ret[idx--]++;
    }
    return ret;
}
```