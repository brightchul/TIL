# 프로그래머스 : 징검다리

## 문제 설명 [[링크]](https://programmers.co.kr/learn/courses/30/lessons/43236)

출발지점부터 distance만큼 떨어진 곳에 도착지점이 있습니다. 그리고 그사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다.
예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다.

| 제거한 바위의 위치 | 각 바위 사이의 거리 | 거리의 최솟값 |
| ------------------ | ------------------- | ------------- |
| [21, 17]           | [2, 9, 3, 11]       | 2             |
| [2, 21]            | [11, 3, 3, 8]       | 3             |
| [2, 11]            | [14, 3, 4, 4]       | 3             |
| [11, 21]           | [2, 12, 3, 8]       | 2             |
| [2, 14]            | [11, 6, 4, 4]       | 4             |

위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다.

출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요.

##### 제한사항

- 도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다.
- 바위는 1개 이상 50,000개 이하가 있습니다.
- n 은 1 이상 `바위의 개수` 이하입니다.

​                      

## 문제 풀이

문제를 풀다가 감을 못 잡아서 결국 검색해서 블로그들을 참고했다. ([1](https://taesan94.tistory.com/154), [2](https://velog.io/@hyeon930/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC-Java))

일단 입력값으로 봤을 때 1,000,000,000 이므로 이분 탐색으로 푸는 것은 이해했다. 그런데 하나의 값으로 확인하는 것인데, n개를 제외한 나머지 값들을 구하거나 그중 최솟값을 구하는 것을 어떻게 이분 탐색으로 해야 하는지 이해가 가지 않았다 . 

이분 탐색은 하나의 값을 구하는 것인데 여러 개를 구할 때 어떻게 적용하는 것일까? 그리고 n개를 제거하는 건 어떻게 적용해야 할까?

최솟값과 징검다리라는 힌트로 보면 조금 접근할 가능성이 존재한다. 저 값들의 구간 속에서 최솟값이라는 것은 모든 구간에 넣더라도 그 구간보다 작거나 같다는 것을 의미힌다. n개를 제외한 이후의 최소값이라는 것은 그 n개를 제외한 구간 일 때에 그 구간들의 값보다 작거나 같다는 것을 의미한다.

```
N : 2
DISTANCE : 25
STONES : [2, 14, 11, 21, 17]

- 17, 21 제거 : 2
[START] [ ][2][ ][ ][ ][ ][ ][ ][ ][ ][11][ ][ ][14][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ] [25]
        [ 2  ][          9               ][   3    ][               9                 ]
==> 각 구간은 2보다 크다


- 2, 21 제거 : 3
[START] [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][11][ ][ ][14][ ][ ][17][ ][ ][ ][ ][ ][ ][ ] [25]
        [             11                 ][   3    ][   3    ][          8             ]
==> 각 구간은 3보다 크다


- 2, 11 제거 : 3
[START] [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][14][ ][ ][17][ ][ ][ ][21][ ][ ][ ] [25]
        [                   14                    ][    3   ][    4      ][     4      ]
==> 각 구간은 3보다 크다


- 11, 21 제거 : 2
[START] [ ][2][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][14][ ][ ][17][ ][ ][ ][ ][ ][ ][ ] [25]
        [ 2  ][                12                 ][   3    ][          8             ]
==> 각 구간은 2보다 크다


- 2, 14 제거 : 4
[START] [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][11][ ][ ][ ][ ][ ][17][ ][ ][ ][21][ ][ ][ ] [25]
        [              11                ][       6         ][    4      ][      4     ]
==> 각 구간은 4보다 크다
```

따라서 이분 탐색으로 하나의 값을 정하고 구간별로 이동하면서 구간이 그 값보다 같거나 큰지 확인하고, 만약 구간이 그 값보다 작다면 그 값은 최솟값이 아니라는 것을 파악하면 된다. 단, 여기서 제거해야 하는 돌 숫자가 n개이므로 이렇게 탐색을 하면서 걸리는 구간 개수가 n개인 거만 확인하면 된다. 

여기서 n개를 초과할 경우에는 선택된 값이 구간보다 더 큰 것이기 때문에 적절하지 못한 값이고 더 작은 값을 찾아야 한다. 반대로 n개 이하일 경우에는 최소값 중 최대값을 찾아야 하므로 더 큰 값을 탐색한다.

​                                            

## 코드 구현



```java

class Solution {
    public int solution(int distance, int[] rocks, int n) {
        Arrays.sort(rocks);

        int left = 0;
        int right = distance;

        while (left <= right) {
            int prev = 0;
            int mid = (left + right) / 2;
            int cnt = 0;

            for (int rock : rocks) {
                if (rock - prev < mid) {
                    cnt++;
                } else {
                    prev = rock;
                }
            }
            if (distance - prev < mid) cnt++;

            if (cnt > n) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        // 최댓값을 찾아야 하므로 right를 반환한다.
        return right;
    }
}
````