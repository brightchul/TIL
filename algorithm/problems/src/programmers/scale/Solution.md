# 프로그래머스 : 저울

## 문제 설명 [[링크]](https://programmers.co.kr/learn/courses/30/lessons/42886)

저울추가 담긴 배열 weight가 매개변수로 주어질 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값을 return 하도록 solution 함수를 작성해주세요.

예를 들어, 무게가 각각 [3, 1, 6, 2, 7, 30, 1]인 7개의 저울추를 주어졌을 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값은 21입니다.

```
[제한 사항]
- 저울추의 개수는 1개 이상 10,000개 이하입니다.
- 각 추의 무게는 1 이상 1,000,000 이하입니다.

[입출력 예]
[3, 1, 6, 2, 7, 30, 1]	return 21
```



## 문제 풀이 

탐욕법으로 푼다고 되어 있어서 처음에는 단순하게 오름차순으로 정렬한 다음에 무게가 무거운 추부터 차례대로 적용해서 없애는 방식으로 시도해 보았다. 시도 결과 정확성 테스트에서는 통과했지만, 효율성 테스트에서 통과할 수가 없었다. 그래서 인터넷을 참고하니 내가 생각했던 것과 다르게 풀이법이 나와있었다.



정렬을 하게 되면 [1,1,2,3,6,7,30] 이 된다.  이것을 누적합 배열로 바꿔보면 [1,2,4,7,13,20, 50] 이 된다.

```
[1,1,2,3,6,7,30], [1,2,4,7,13,20, 50] 

 1-> 1 | 1
 1-> 2 | 1,2
 2-> 4 | 1,2,3,4
 3-> 7 | 1,2,3,4,5,6,7
 6->13 | 1,2,3,4,5,6,7,8,9,10,11,12,13
 7->20 | 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20
30->50 | 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20, //21~29 단절// 30, ..., 50
```

개수가 n개인 배열 arr이 있다고 하자. 여기서 n까지의 누적합을 acc(n)이라고 하겠다.

각 배열의 원소값이 이전 배열 원소까지의 누적합보다 +1이하라면 1부터 현재 원소의 누적합까지의 모든 저울 값을 다 조합으로 만들어 낼 수 있다. 따라서 이전 배열 원소까지의 누적합과 현재 배열 원소값 사이의 차이만 비교하면 되는 것이다.



## 코드 구현

```java
public int solution(int[] weight) {
    Arrays.sort(weight);
    int acc = 1;	// +1만큼 더해줘서 비교해야하는데 미리 1을 준다. 누적합
    for(int i=0; i<weight.length; i++) {
        if(weight[i] > acc) {
            break;
        }
        acc+= weight[i];
    }
    return acc;
}
```