# 프로그래머스 : 셔틀버스

## 문제 설명 [[링크]](https://programmers.co.kr/learn/courses/30/lessons/17678)

카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 '크루'라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다.

이 문제에서는 편의를 위해 셔틀은 다음과 같은 규칙으로 운행한다고 가정하자.

- 셔틀은 `09:00`부터 총 `n`회 `t`분 간격으로 역에 도착하며, 하나의 셔틀에는 최대 `m`명의 승객이 탈 수 있다.
- 셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다. 예를 들어 `09:00`에 도착한 셔틀은 자리가 있다면 `09:00`에 줄을 선 크루도 탈 수 있다.

일찍 나와서 셔틀을 기다리는 것이 귀찮았던 콘은, 일주일간의 집요한 관찰 끝에 어떤 크루가 몇 시에 셔틀 대기열에 도착하는지 알아냈다. 콘이 셔틀을 타고 사무실로 갈 수 있는 도착 시각 중 제일 늦은 시각을 구하여라.

단, 콘은 게으르기 때문에 같은 시각에 도착한 크루 중 대기열에서 제일 뒤에 선다. 또한, 모든 크루는 잠을 자야 하므로 `23:59`에 집에 돌아간다. 따라서 어떤 크루도 다음날 셔틀을 타는 일은 없다.



```
[입력]
셔틀 운행 횟수 n, 셔틀 운행 간격 t, 한 셔틀에 탈 수 있는 최대 크루 수 m, 
크루가 대기열에 도착하는 시각을 모은 배열 timetable이 입력으로 주어진다.

- 0 ＜ n ≦ 10
- 0 ＜ t ≦ 60
- 0 ＜ m ≦ 45

timetable은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이 
HH:MM 형식으로 이루어져 있다. 크루의 도착 시각 HH:MM은 00:01에서 23:59 사이이다.

[출력]
콘이 무사히 셔틀을 타고 사무실로 갈 수 있는 제일 늦은 도착 시각을 출력한다. 
도착 시각은 HH:MM 형식이며, 00:00에서 23:59 사이의 값이 될 수 있다.

[입출력 예제]

n	t	m	timetable							answer
1	1	5	[08:00, 08:01, 08:02, 08:03]		09:00
2	10	2	[09:10, 09:09, 08:00]				09:09
2	1	2	[09:00, 09:00, 09:00, 09:00]		08:59
1	1	5	[00:01, 00:01, 00:01, 00:01, 00:01]	00:00
```



## 문제 풀이 

문제의 입력 배열 (timetable)이 정렬되어 있다는 보장이 없다. 그러므로 정렬을 따로 하거나 우선순위 큐, 힙 같은 것을 사용하면 좋다. 

제일 늦게 나갈 수 있는 시간대를 구해야 하므로 그 전 시간대까지 차량을 탈 수 있는 사람들은 전부 없애줘야 나중에 연산하기가 편하다. 따라서 마지막 회차를 제외한 다른 회차들에 대해서 반복문을 돌면서 그 시간 전에 대기하고 있던 사람들을 전부 제거해 준다.

마지막 시간대일 때에는 몇가지 고려해야 해야 한다.

```
// 타는 사람이 하나도 없을 때
하나도 없을 때에는 해당 차량 도착 시간대를 그대로 적용하면 된다.

// 타는 사람이 m보다 적을 때
마찬가지로 m보다 적은 사람이 타니까 남는 자리가 1자리 이상 존재하고, 
차량 도착 시간에 그대로 적용하면 된다.

// m만큼 있을 때
만약 10시에 도착한다 하고 탑승객 m이 5일때 여러 경우들이 존재할 것이다.
- 10:00, 10:00, 10:00, 10:00, 10:00
- 09:59, 09:59, 09:59, 09:59, 10:00
- 09:58, 09:59, 10:00, 10:00, 10:00

1번째 경우에는 모든 사람보다 빨라야 하므로 09:59가 되어야 한다.
2번째 경우에는 마지막 사람보다 빠르면 되므로 09:59가 되어야 한다.
3번째의 경우는 10시가 되면 4번째가 되므로 09:59가 되어야 한다.

각 시간 별로 카운트를 해서 파악해야 할까 잠시 생각했지만 그럴 필요가 없다.
애초에 m만큼 있을 때는 그냥 있으면 무조건 탈수가 없고, 
맨 마지막 승차하는 사람과 같은 시간대가 되어도 맨뒤에 서게되므로 무조건 탈 수 없다.
하지만 맨 마지막 승차하는 사람보다 1분 빠르면 맨 마지막 타는 사람보다 앞서게 되므로 탈 수 있다.

따라서 승차하는 사람 중 맨 마지막에 타는 사람의 시간대를 구해서 -1분만 하면 된다.
```







## 코드 구현 [[전체코드]](./Solution.java)



```java
public String solution(int n, int t, int m, String[] timetable) {
    
    // 우선순위 큐 생성 (+정렬)
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    for(int i=0; i<timetable.length; i++) {
        pq.add(convertMin(timetable[i]));	// 편이를 위해 분으로 바꾼다.
    }

    // 마지막 차시간 전까지 각 시간대로 대기인원을 없앤다.
    int arrivedMin = 9 * 60;
    for(int i=1; i<n; i++) {
        int count = 0;
        while(count < m) {
            if(pq.peek() <= arrivedMin) {
                count++;
                pq.poll();
            } else {
                break;
            }
        }
        arrivedMin += t;
    }

    // 마지막 시간대에 타는 사람 카운트 및 계산
    Map<Integer, Integer> map = new HashMap<>();
    int passengersCount = 0;
    while(passengersCount < m) {
        if(pq.size() == 0) break;
        if(pq.peek() <= arrivedMin) {
            int one = pq.poll();
            map.put(one, Optional.ofNullable(map.get(one)).orElse(0) + 1);
            passengersCount++;
        } else {
            break;
        }
    }

    
    // 마지막 시간대에 타기 위한 최대 늦은 시간 계산
    int result = 0;
    if(passengersCount == m) {
        Integer[] arr = map.keySet().toArray(new Integer[map.size()]); // 타는 사람 시간대 구함
        result = arr[arr.length-1] -1; // 맨 마지막 타는 사람보다 1분 앞서게 한다.
    } else {
        result = arrivedMin;
    }

    String answer = String.format("%02d:%02d", result/60, result%60);
    return answer;
}
```

