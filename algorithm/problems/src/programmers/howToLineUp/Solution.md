# 프로그래머스 : 줄 서는 방법

## 문제 설명 [[링크]](https://programmers.co.kr/learn/courses/30/lessons/12936)

n명의 사람이 일렬로 줄을 서고 있습니다. n명의 사람들에게는 각각 1번부터 n번까지 번호가 매겨져 있습니다. n명이 사람을 줄을 서는 방법은 여러가지 방법이 있습니다. 예를 들어서 3명의 사람이 있다면 다음과 같이 6개의 방법이 있습니다.

[1, 2, 3],  [1, 3, 2],  [2, 1, 3],  [2, 3, 1],  [3, 1, 2],  [3, 2, 1]

사람의 수 n과, 자연수 k가 주어질 때, 사람을 나열 하는 방법을 사전 순으로 나열 했을 때, k번째 방법을 return하는 solution 함수를 완성해주세요.

```
[제한사항]
- n은 20이하의 자연수 입니다.
- k는 n! 이하의 자연수 입니다.

[입출력 예]
n=3, k=5, return [3,1,2]
```



## 문제 풀이

줄 세우기의 경우의 수는 팩토리얼이다. 제한조건이 20이하인데 20!는 2,432,902,008,176,640,000 이다. 따라서 단순히 브루트포스로 찾기에는 가짓수가 너무 많다. 따라서 다른 방법을 찾아야 한다.

```
n=1
[1]

n=2
[1,2] 
[2,1]

n=3
[1,2,3] [1,3,2]
[2,1,3] [2,3,1]
[3,1,2] [3,2,1]

n=4
[1,2,3,4] [1,2,4,3] [1,3,2,4] [1,3,4,2] [1,4,2,3] [1,4,3,2]
[2,1,3,4] [2,1,4,3] [2,3,1,4] [2,3,4,1] [2,4,1,3] [2,4,3,1]
[3,1,2,4] [3,1,4,2] [3,2,1,4] [3,2,4,1] [3,4,1,2] [3,4,2,1]
[4,1,2,3] [4,1,3,2] [4,2,1,3] [4,2,3,1] [4,3,1,2] [4,3,2,1]

...
```

4일 때 줄 서는 방법은 4! = 4x3x2x1이다. 각 배열의 맨 앞 요소가 각각 1, 2, 3, 4인데 각각 요소별로 6개씩 존재한다는 것을 알 수 있다.  n=4일 때 총 가짓수는 4!이고, 맨 앞 요소를 제외하면 3!, 그 다음 요소를 제외하면 2! .. 이렇게 진행이 된다.

```
arr[0]==1 : 1 <= k <=  6
arr[0]==2 : 7 <= k <= 12
arr[0]==3 :13 <= k <= 18
arr[0]==4 :19 <= k <= 24
```

i번째 요소를 구했으면 그 요소를 제외한 배열들로 다시 i+1을 구하고 이런식으로 계속해서 반복해서 구하면 된다.

k번째, 총길이 n, 인덱스 i, 라고 할때 `(int)(k / (n-i-1)!)`  를 사용하고, 나머지 값을 다시 k값으로 넘기는 식으로 진행하면 되는데, 나머지가 0인 경우에는 해당 i 이후의 배열은 역순으로 진행되는 특징이 있다. 

```
[예시]
n=4, k=6인 경우
k % (4-1)! = 몫1, 나머지 0
따라서 1로 시작되는 배열이며 1을 제외한 나머지 배열은 역순으로 된다.
1, [2,3,4] ==> [1,4,3,2]
```



## 코드 구현 [[전체코드]](Solution.java)

```java
public int[] solution(int n, long k) {
    ArrayList<Integer> list = new ArrayList<>(n+1);	// 편이성을 위해 1부터 시작
    int[] result = new int[n];	// 결과 배열
    int rIdx = 0;			// 결과배열을 넣기 위한 인덱스
    long pacValue = 1;		// 팩토리얼 값, 효율성 테스트 패스를 위해 long

    // ... 중략
    
    while(list.size() > 1) {
        pacValue /= list.size()-1;
        int idx = (int)Math.ceil((double)k/pacValue);
        result[rIdx++] = list.get(idx);
        list.remove(idx);

        // 나머지가 0이면 역순 배열 구하고 바로 종료
        if(k % pacValue == 0) {
            for(int i=list.size()-1; i>0; i--)
                result[rIdx++] = list.get(i);
            break;
        }
        // 아니면 k값 반영하고 계속 진행
        k = k % pacValue;
    }
    return result;
}
```

