# 알고스팟 문제 : 변화하는 중간 값

## 문제 설명 [[링크]](https://algospot.com/judge/problem/read/RUNNINGMEDIAN)

한 수열의 중간값(median)은 이 수열을 정렬했을 때 가운데 오는 값입니다. 예를 들어 {3,1,5,4,2}를 정렬했을 때 가운데 오는 값은 3이지요. 수열의 길이가 짝수일 때는 가운데 있는 두 값 중 보다 작은 것을 수열의 중간값이라고 정의하도록 합시다.

한 수열의 중간값은 수열에 새로운 수가 추가될 때마다 바뀔 수 있습니다. 텅 빈 수열에서 시작해서 각 수가 추가될 때마다 중간값을 계산하는 프로그램을 작성하세요. 예를 들어 3, 1, 5, 4, 2 순서대로 숫자가 추가될 경우 수열의 중간값은 3, 1, 3, 3, 3 순서로 변화합니다.



**입력 생성**

입력의 크기가 큰 관계로, 이 문제에서는 수열을 입력받는 대신 다음과 같은 식을 통해 프로그램 내에서 직접 생성합니다. a와 b는 입력에 주어지는 상수입니다. 이 문제의 해법은 입력을 생성하는 방식과는 아무 상관이 없습니다.

- A[0] = 1983 
- A[i] = (A[i-1] * a + b) % 20090711



**입력**

입력 파일의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 20)가 주어지고, 그 후 C줄에 각 3개의 정수로 수열의 길이 N (1 <= N <= 200,000), 그리고 수열을 생성하는 데 필요한 두 정수 a , b (0 <= a,b <= 10000) 가 주어집니다.

**출력**
각 테스트 케이스마다 한 줄에 N개의 중간값의 합을 20090711로 나눈 나머지를 출력합니다.



```
[예제 입력]
3
10 1 0
10 1 1
10000 1273 4936

[예제 출력]
19830 
19850 
2448920
```



## 문제 풀이

알고리즘 문제 해결 전략 2권 챕터 23에 잘 나온다.

중간 값을 구하기 위해서 2개의 힙을 이용한다. 첫번째 힙은 중간이하의 값들을 저장하고, 두번째 힙은 중간초과의 값들을 저장한다.

문제에서 홀수일 경우 가운데, 짝수일 경우에는 중간 2개 중에서 작은 값을 정하기로 했으므로, 첫번째 힙은 두번째 힙보다 사이즈가 크거나 같아야 한다. 즉 총 개수가 홀수일 때는 첫번째 힙이 더 많고,  짝수일 때는 사이즈가 같은 것이다.

입력 자체가 계속해서 정렬을 O(lg)로 정렬 하기 때문에 확인할 때는 peek()해서 확인하면 된다. 첫번째 힙은 중간 이하값중에 가장 큰 값이 바로 중간값일테고, 두번째 힙은 중간을 초과하는 값들중에 가장 작은 값이 peek()으로 확인이 된다.

따라서 첫번째 힙의  최대값 peek()과 두번째 힙의 최소값 peek() 을 비교하면 혹시나 두번 째 힙에 첫번째 힙에 들어갔어야 하는 작은 값이 들어갔을지라도 확인하고 조정해 줄 수 있다. 두 힙의 peek()값을 서로 상대 힙에 넣어주면 된다.



## 코드 구현 [[전체코드]](./Main.java)

```java
public static int run(int len, int a, int b) {
    PriorityQueue<Integer> nextH= new PriorityQueue<>();
    PriorityQueue<Integer> prevH = new PriorityQueue<>(Collections.reverseOrder());

    int ret = 0;
    RNG rng = new RNG(a, b);
    
    for(int i=0; i<len; i++) {
        // 첫번째 힙의 사이즈가 두번째 힙의 사이즈보다 같거나 커야 한다.
        if(prevH.size() <= nextH.size()) {
            prevH.add(rng.next());
        } else {
            nextH.add(rng.next());
        }
		
        // 두 힙의 peek() 값을 확인하여 조정한다.
        if(nextH.size() > 0 && prevH.peek() > nextH.peek()) {
            int temp = prevH.poll();
            prevH.add(nextH.poll());
            nextH.add(temp);
        }
        ret = (ret + prevH.peek()) % 20090711;
    }
    return ret;
}
```

