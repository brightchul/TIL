# 백준 온라인 저지 : 히스토그램에서 가장 큰 직사각형

## 문제 설명 [[링크]](https://www.acmicpc.net/problem/6549)

히스토그램은 직사각형 여러 개가 아래쪽으로 정렬되어 있는 도형이다. 각 직사각형은 같은 너비를 가지고 있지만, 높이는 서로 다를 수도 있다. 예를 들어, 왼쪽 그림은 높이가 2, 1, 4, 5, 1, 3, 3이고 너비가 1인 직사각형으로 이루어진 히스토그램이다.

히스토그램에서 가장 넓이가 큰 직사각형을 구하는 프로그램을 작성하시오.


```
[입력]
입력은 테스트 케이스 여러 개로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, 직사각형의 수 n이 
가장 처음으로 주어진다. (1 ≤ n ≤ 100,000) 그 다음 n개의 정수 h1, ..., hn (0 ≤ hi ≤ 1,000,000,000)가 주어진다. 
이 숫자들은 히스토그램에 있는 직사각형의 높이이며, 왼쪽부터 오른쪽까지 순서대로 주어진다. 
모든 직사각형의 너비는 1이고, 입력의 마지막 줄에는 0이 하나 주어진다.

[출력]
각 테스트 케이스에 대해서, 히스토그램에서 가장 넓이가 큰 직사각형의 넓이를 출력한다.

[예시]
7 2 1 4 5 1 3 3
4 1000 1000 1000 1000
6 2 1 3 2 2 1
1 0
0

return
8
4000
6
0
```





## 문제풀이

백준 온라인 저지에 [[설명]](https://www.acmicpc.net/blog/view/12)이 잘 나와있다. 이 문제는 스택을 이용해서 풀었다.

​    

**적절한 정수 타입 선택**

문제에서 `직사각형의 수 n이 가장 처음으로 주어진다. (1 ≤ n ≤ 100,000) 그 다음 n개의 정수 h1, ..., hn (0 ≤ hi ≤ 1,000,000,000)가 주어진다` 라고 되어 있다. 따라서 최대수는 10^14이므로 java의 int 최대 범위보다 크므로 long을 써줘야 한다.

​    

**스택 이용**

스택에는 인덱스를 저장해준다. 

먼저 스택을 이용해서 채워넣고 빼면서 계산할 때에는 한가지 암묵적인 전제가 존재한다. 스택의 가장 윗 값보다 같거나 큰 것만 넣는 것이다. 이렇게 되면 스택의 가장 위에 있는 것은 스택 내부에서 가장 값이 큰 인덱스를 가리키게 되며 그 다음 스택의 요소는 그다음으로 큰 인덱스를 가지게 된다. 

이렇게 되면 이전 인덱스의 값이 직사각형의 시작이 스택의 그 다음 요소의 인덱스 다음칸으로부터 시작을 하고, 넣어주려는 값 바로 이전 칸이 직사각형의 끝이 된다. 즉 이 2가지 지점이 직사각형의 길이가 되며 높이는 스택의 가장 위에 있는 요소의 인덱스의 값이 되는 것이다. 

그러면 로직을 전개해보면 아래의 3가지 경우가 존재한다. 

1. `스택이 비워져 있을 때`에는 그냥 넣어주면 된다.
2. `스택 가장 윗 값  <= 넣어주려는 인덱스의 값일 때`에도 그냥 넣어주면된다.
3. `스택 가장 윗 값  > 넣어주려는 인덱스의 값일 때 ` 에는 조금 복잡하니 부연설명을 한다.

​    

**스택 가장 윗 값  > 넣어주려는 인덱스의 값**

넣어주려는 인덱스의 값보다 스택의 가장 윗 값 (stack의 top)이 크다면 먼저 stack.pop을 해서 꺼낸다. 이 pop한 값은 인덱스이고 배열의 인덱스에 해당하는 값이 직사각형의 높이가 된다.

그다음 직사각형의 시작, 끝을 구해야 하는데 각각 left, right라고 하겠다. 

- `left = stack.top에 있는 인덱스 값 + 1 또는 stack.isEmpty라면 0``
- ``right = 넣어주려는 인덱스의 값 - 1`
- `직사각형의 길이 = right - left + 1`
- `직사각형의 넓이 = 직사각형의 길이 * pop한 인덱스의 배열 값`

​    

**아직 끝나지 않았다.**

순회를 하면서 1,2,3의 경우에 따라서 로직을 전체하고 그 결과를 큰 값 위주로 계속 업데이트 하면 답은 나올거 같지만, 스택이 비워지지 않고 순회가 끝날수 있다. 이럴 경우에 스택을 비우기 위해서 추가적인 반복문을 돌면서 모든 값들을 pop해가며 너비를 마저 구해줘야 한다.

이 때 right는 length -1이라는 점이다. 즉 마지막 지점이 right가 된다. 스택 자체가 비워지지 않았다는 것은 직사각형 배열의 마지막 부분이 스택의 모든 값보다 크거나 같았기 때문이다. 따라서 스택안의 모든 직사각형들의 영역은 마지막 항목을 포함한다는 것이 된다. 



## 코드 구현 [[전체코드]](./Main.java)

```java
public static long solution(long[] arr) {
    long result = 0;
    Stack stack = new Stack(arr.length);

    for (int i = 0; i < arr.length; i++) {
        while (true) {
            if (stack.isEmpty() || arr[stack.top()] <= arr[i]) {
                stack.push(i);
                break;
            } else {
                result = Math.max(result, getArea(arr, stack, i));
            }
        }
    }

    // stack이 비워지지 않았을 경우
    int i = arr.length;
    while (!stack.isEmpty()) {
        result = Math.max(result, getArea(arr, stack, i));
    }
    return result;
}

public static long getArea(long[] arr, Stack stack, int i) {
    int one = stack.pop();
    int left = stack.isEmpty() ? 0 : stack.top() + 1;
    int right = i - 1;
    return arr[one] * (right - left + 1);
}
```

