# 백준 온라인 저지 : 골드바흐의 추측 

## 문제 설명 [[링크]](https://www.acmicpc.net/problem/6588)

1742년, 독일의 아마추어 수학가 크리스티안 골드바흐는 레온하르트 오일러에게 다음과 같은 추측을 제안하는 편지를 보냈다.

4보다 큰 모든 짝수는 두 홀수 소수의 합으로 나타낼 수 있다.      
예를 들어 8은 3 + 5로 나타낼 수 있고, 3과 5는 모두 홀수인 소수이다.      
또, 20 = 3 + 17 = 7 + 13, 42 = 5 + 37 = 11 + 31 = 13 + 29 = 19 + 23 이다.

이 추측은 아직도 해결되지 않은 문제이다.

백만 이하의 모든 짝수에 대해서, 이 추측을 검증하는 프로그램을 작성하시오.

```
[입력]
입력은 하나 또는 그 이상의 테스트 케이스로 이루어져 있다. 테스트 케이스의 개수는 100,000개를 넘지 않는다.
각 테스트 케이스는 짝수 정수 n 하나로 이루어져 있다. (6 ≤ n ≤ 1000000)
입력의 마지막 줄에는 0이 하나 주어진다.

[출력]
각 테스트 케이스에 대해서, 히스토그램에서 가장 넓이가 큰 직사각형의 넓이를 출력한다.

[예시]
8
20
42
0

return
8 = 3 + 5
20 = 3 + 17
42 = 5 + 37
```

​     

## 문제풀이

테스트 케이스가 최대 1,000,000이며 테스트 케이스 개수가 100,000개를 넘지 않는다고 한다. 

백만까지의 소수 개수는 168개 정도가 된다. 따라서 소수 갯수만 구하면 168 * 100,000 이므로 대략 1억 조금 넘게 나오므로 그냥 진행하면 된다.



​     

## 코드 구현 [[전체코드]](./Main.java)

에라토스테네스의 체를 이용해서 소수 배열( arr)을 구하고, 다시 그 결과를 따로 배열(primeArr)로 정리한다.

하나는 소수들을 순회하기 위함이고, 다른 하나는 각 값에서 소수를 뺀 나머지 값이 소수인지를 빠르게 파악하기 위함이다.

```java
public static void initPrimeArr() {
  arr[0] = arr[1] = 1;
  int last = (int) Math.sqrt(NUM);
  for (int idx = 2; idx <= last; idx++) {
    if (arr[idx] > 0) continue;
    for (int i = idx * idx; i <= NUM; i += idx) {
      arr[i] = 1;
    }
  }
  int len = 0;
  int[] temp = new int[last];
  for (int i = 2; i <= last; i++) {
    if (arr[i] == 0) {
      temp[len++] = i;
    }
  }
  primeArr = Arrays.copyOf(temp, len);
}
```

그 다음 구하려는 숫자값을 받아서 소수들을 순회하면서 두값이 전부 소수인지를 확인한다.

```java
public static int getSolutionIdx(int target) {
  int last = target / 2;
  for (int i = 0; primeArr[i] <= last; i++) {
    if (arr[target - primeArr[i]] == 0) {
      return i;
    }
  }
  return -1;
}
```

