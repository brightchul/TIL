# 백준 온라인 저지 : 동전 2

## 문제 설명 [[링크]](https://www.acmicpc.net/problem/2294)

n가지 종류의 동전이 있다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그러면서 동전의 개수가 최소가 되도록 하려고 한다. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.



```
[입력]
첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 
각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다. 
가치가 같은 동전이 여러 번 주어질 수도 있다.

[출력]
첫째 줄에 사용한 동전의 최소 개수를 출력한다. 불가능한 경우에는 -1을 출력한다.

[예시1]
3 15
1
5
12

return
3

[예시2]
3 5
100
101
102

return 
-1
```





## 문제풀이

문제 [[동전1]](../p2294/Solution.md) 과 거의 같은 형태의 문제이다. 동전1의 경우에는 총 경우의 수라면 이 문제에서는 경우의 수중에서 가장 최소의 갯수를 파악하는 것이 차이점이다.  이해하기 쉽게 표로 보자.

| coin | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| 5    | 0    | 1    | 2    | 3    | 4    | 1    | 2    | 3    | 4    | 5    | 2    | 3    | 4    | 5    | 6    | 3    |
| 12   | 0    | 1    | 2    | 3    | 4    | 1    | 2    | 3    | 4    | 5    | 2    | 3    | 1    | 2    | 3    | 3    |

12를 보면 마지막 부분에 1,2,3,3 으로 끝나는 것을 볼 수 있다. 15일 때 `1 1 1 12` 보다 `5 5 5 `가 더 15를 만드는데 적은 동전을 사용하기 때문이다.

`cache[row][idx-coin] + 1` 과 `cache[row-1][idx]` 중에 최소값을 찾아서 cache 계속 누적해 나간다음 마지막 인덱스의 마지막 row값을 반환하면 된다. 이때 +1을 하는 이유는 이전 값에 현재 값을 더한게 순회할때 현재 목표값에 부합되는 것이고 이 부합되는 순간의 갯수를 파악하기 위함이다. 마지막 값을 반환할 때 불가능일 경우에는 -1을 하면 된다.



## 코드 구현 [[전체코드]](./Main.java)

문제를 보면 최대 갯수 100개, 최대 동전 값 100,000이다. 즉 모든 동전으로 만들 수 있는 최대값은 10,000,000 이다. 따라서 10,000,003으로 불가능한 경우를 해주고 Math.min으로 최소값을 파악하는 식으로 로직을 구성하면 된다. 

그리고 만약 불가능한 경우에는 10,000,003이 나올 것이기 때문에 이 경우만 파악해서 -1을 반환하면 된다.

```java
private static final int IMPOSSIBLE = 1_000_000_003;

public static int solution() {
    for (int i = 0; i < len; i++) {
        int one = arr[i];
        for (int j = 1; j <= target; j++) {
            cache[i][j] = Math.min(
                getValue(i, j - one) + 1, getValue(i - 1, j));
        }
    }
    return cache[len - 1][target] == IMPOSSIBLE ? -1 : cache[len-1][target];
}

public static int getValue(int row, int col) {
    if (row < 0 || col < 0) return IMPOSSIBLE;
    if (row > cache.length || col > cache[0].length) return IMPOSSIBLE;
    return cache[row][col];
}
```

