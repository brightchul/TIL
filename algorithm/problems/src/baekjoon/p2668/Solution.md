# 백준 온라인 저지 : 숫자고르기

## 문제 설명 [[링크]](https://www.acmicpc.net/problem/2668)

세로 두 줄, 가로로 N개의 칸으로 이루어진 표가 있다. 첫째 줄의 각 칸에는 정수 1, 2, …, N이 차례대로 들어 있고 둘째 줄의 각 칸에는 1이상 N이하인 정수가 들어 있다. 첫째 줄에서 숫자를 적절히 뽑으면, 그 뽑힌 정수들이 이루는 집합과, 뽑힌 정수들의 바로 밑의 둘째 줄에 들어있는 정수들이 이루는 집합이 일치한다. 이러한 조건을 만족시키도록 정수들을 뽑되, 최대로 많이 뽑는 방법을 찾는 프로그램을 작성하시오. 예를 들어, N=7인 경우 아래와 같이 표가 주어졌다고 하자.

```
[1, 2, 3, 4, 5, 6, 7]
[3, 1, 1, 5, 5, 4, 6]
```

이 경우에는 첫째 줄에서 1, 3, 5를 뽑는 것이 답이다. 첫째 줄의 1, 3, 5밑에는 각각 3, 1, 5가 있으며 두 집합은 일치한다. 이때 집합의 크기는 3이다. 만약 첫째 줄에서 1과 3을 뽑으면, 이들 바로 밑에는 정수 3과 1이 있으므로 두 집합이 일치한다. 그러나, 이 경우에 뽑힌 정수의 개수는 최대가 아니므로 답이 될 수 없다.


```
[입력]
첫째 줄에는 N(1≤N≤100)을 나타내는 정수 하나가 주어진다. 그 다음 줄부터는 표의 
둘째 줄에 들어가는 정수들이 순서대로 한 줄에 하나씩 입력된다.

[출력]
첫째 줄에 뽑힌 정수들의 개수를 출력하고, 그 다음 줄부터는 뽑힌 정수들을 
작은 수부터 큰 수의 순서로 한 줄에 하나씩 출력한다.

[예시]
7
3
1
1
5
5
4
6

출력
3
1
3
5
```



​    

## 문제풀이

쉽게 말하면 각 인덱스 (1 ~ n)에서 시작해서 인덱스에 있는 값을 타고 해당 인덱스로 계속 타고 넘어갔을 때 원래 인덱스로 돌아올 수 있는지, 만약 돌아온다면 그 경로의 값들을 오름차순으로 출력하는 문제이다.  예제에선 1,3이 서로 연결되어 있고, 5는 5가 들어가 있으므로 1, 3, 5를 출력하는 것이다.

서로 연결되어 있으면 무한으로 계속 순회할수 있으므로 이미 지나온 값들은 캐시를 해서 재방문했을 때는 중단시킨다.



​    

## 코드 구현 [[전체 코드]](./Main.java)

각 배열의 값들을 순회한다. 입력값들이 1부터 시작하므로 헷갈리는 것을 방지하기 위해 len+1로 배열을 생성했다.

```java
int[] arr = new int[len+1];

// ...

for(int i=1; i<=len; i++) {
    if(run(i, i, arr, new ArrayList<>()))
        list.add(i);
}
```

origin은 처음 시작한 인덱스로 시작한 인덱스로 돌아와야 하기 때문에 인자로 계속 넘겨준다. list는 처음 호출할 때 새로 생성해서 넣어주는 리스트로 캐시로 이미 지나간 인덱스를 저장해서 확인한다.

```java
public static boolean run(int origin, int one, int[] arr, List<Integer> list) {
    if(origin == arr[one]) return true;
    
    // 1 -> 4 -> 2 -> 4... 이런식으로 될 경우 false를 반환하기 위함
    if(list.contains(arr[one])) {
        return list.contains(origin);
    }
    list.add(arr[one]);
    return run(origin, arr[one], arr, list);
}
```