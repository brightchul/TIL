# 3장 다이내믹 프로그래밍의 이해

## 3.1 다이내믹 프로그래밍이란?

> 다이내믹 프로그래밍은 문제를 푸는 전략중 하나의 이름이며 프로그래밍과는 무관하다.

| 종류                       | 설명                                                   |
| -------------------------- | ------------------------------------------------------ |
| 상향식 다이내믹 프로그래밍 | 밑에서 부터 상향식으로 문제를 해결                     |
| 하향식 다이내믹 프로그래밍 | 메모이제이션을 사용, 재귀호출을 사용해 하향식으로 동작 |

​       

### 연습문제

> O(logn)에 피보나치 수를 계산하는 피보나치 함수를 작성해 보자. (선형대수 이해 필요)

https://www.geeksforgeeks.org/program-for-nth-fibonacci-number

​       

### 역 사이 최소 비용 구하기

- 이전 메모 전략 코드에서는 O(n^3)만큼의 실행 시간이 필요
- 상향식 다이내믹 프로그래밍 방법으로 O(n^2)의 시간 복잡도와 O(n)만큼의 추가공간 필요



#### 점화식 규칙

```
minCost[0] = 0;

minCost[1] = cost[0][1];

minCost[2] = minCost[0] + cost[0][2], 
             minCost[1] + cost[1][2]
             
minCost[3] = minCost[0] + cost[0][3], 
             minCost[1] + cost[1][3], 
             minCoat[2] + cost[2][3]
...
minCost[n] = minCost[0] + cost[0][n],
             minCost[1] + cost[1][n],
             ...
             minCost[n-1] + cost[n-1][n]
```

​           

#### 코드로 구현해보자

```javascript
const cost = [
  [0, 10, 75, 94],
  [-1, 0, 35, 50],
  [-1, -1, 0, 80],
  [-1, -1, -1, 0],
]

const MAX = Number.MAX_SAFE_INTEGER;

function getMinCost(n, cost) {
  if(n===0) return 0;
  
	const minCost = Array(n+1).fill(MAX);
  minCost[0] = 0;
  
  for(let i=1; i<=n; i++) {
		for(let j=0; j<i; j++) {
			minCost[i] = Math.min(minCost[i], minCost[j] + cost[j][i]);
    }
  }
  return minCost[n];
}
```

​        

### 예제 : 부분 문자열 다루기

숫자로 이루어진 문자열이 있다. 이 숫자열의 부분 문자열중 앞부분 절반 숫자의 합과 뒷부분 절반 숫자의 합이 같은 부분 문자열 가운데 가장 긴 부분 문자열의 길이를 구해보자.

```
예)

입력 : 142124
출력 : 6
설명 : 142 & 124의 합이 같으므로 이 두개를 합친 142124의 길이인 6이 출력된다.

입력 : 9430723
출력 : 4
설명 : 여기서는 43 & 07의 합이 각각 같기 때문에 4307 즉 4가 답이다.
```



### 풀이

절반으로 나눠야 하기 때문에 문자열의 길이는 짝수이어야 한다.

​    

#### 완전 탐색 (brute-force)

```javascript
function maxSubStringLength(str) {
  let n = str.length;
  let maxLen = 0;
  
  // i 부분 문자열의 시작 인덱스
  for(let i=0; i<n; i++) {
    
    // j 부분 문자열의 끝 인덱스 (짝수 길이)
    for(let j = i+1; j<n; j+= 2) {
      // len = 현재 부분 문자열의 길이
      let len = j - i + 1;
      
      // 만약 지금까지의 maxLen이 검사하려는 문자열보다 길면
      // 현재 문자열을 검사(앞쪽, 뒤족 절반의 숫자의 합이 같은지) 하지 않는다.
      if(maxLen >= len) continue;
      
      let lSum = 0, rSum = 0;
      
      for(let k=0; k< len/2; k++) {
        lSum += (+str[i+k]);
        rSum += (+str[i+k+len/2]);
      }
      if(lSum == rSum) maxLen = len;
    }
  }
	return maxLen;
}
```

​      

#### 다이내믹 프로그래밍

이 문제에서 중복 반복계산 부분을 피해보자. 부분 문자열의 숫자 합을 구하는 가장 기본적인 경우는 부분 문자열의 글자가 한 글자인 경우이다. 이를 두 글자, 세 글자 순서로 늘려가면서 상향식으로 계산한다.

```
S(i,j) = 문자열의 i번째 숫자부터 j번째 숫자까지의 합

1. 길이 1의 부분 문자열(i=j) 숫자의 합  S(i,i)은 i번째 숫자의 값이다.
2. 길이 2의 부분 문자열 숫자의 합 S(i,j) = S(i,i) + S(j,j) 이며, 
   S(I, i)와 S(j,j)는 1번 단계에서 이미 계산되어 있다.
3. 길이 3인 부분 문자열 숫자의 합 S(i,j)는 한 글자 부분 문자열의 숫자의 합과 두 글자 부분 문자열의 숫자의 합인데 
   각각 1번 단계와 2번 단계에서 계산되어 있다.
```

이것을 일반화 하면 다음과 같다.

```
S(i, j) = S(i, k) + S(k + 1, j)
```

​      

#### 코드 구현

```javascript
function maxSubstringLength(str) {
  let n = str.length;
  let maxLen = 0;
  
  // sum[i][j] = 인덱스 i에서 인덱스 j까지의 숫자의 합
  // i > j인 경우의 값은 사용하지 않는다
 	const sum = Array(n).fill(0).map(_=>[]);
  
  // 행렬 대각선 아래쪽 i > j 은 사용하지 않는다
  // 대각선 위치의 값을 채워 넣는다
  for(let i = 0; i<n; i++)
		sum[i][i] = +str[i];
  
  for(let len = 2; len <= n; len++) {
    //현재 부분 문자열의 i와j를 선택
    for(let i=0; i<n-len+1; i++) {
      let j = i + len-1;
      let k = parseInt(len/2);
      
      // sum[i][j]의 값을 계산
      sum[i][j] = sum[i][j-k] + sum[j-k+1][j];
      
      // len이 짝수이고 왼쪽과 오른쪽 절반의 합이 같으며
      // len이 maxLen보다 크면 maxLen을 갱신한다.
      if(len % 2 === 0 && sum[i][j-k] == sum[j-k+1][j] && len > maxLen)
        maxLen = len;
    }
  }
  return maxLen;
}
```

다이내믹 프로그래밍 방법을 사용해 개선된 함수는 O(n^2)의 시간 복잡도를 가지며 O(n^2)만큼 메모리를 사용한다. 희소배열로 메모리 사용량을 줄여볼 여지가 있다.



### 연습문제

> 이번절 예제에 대하여 추가메모리는 O(1) 만큼만 사용하는 풀이법을 찾아보자

​                   

## 3.2 하향식 접근 방법과 상향식 접근 방법

앞의 절에서 문제를 해결한 방식이 하향식 방법이라면, 다이내믹 프로그래밍은 상향식 접근 방법이다.

​       

### 예제 : 계승 함수

#### 하향식 접근방법

- 재귀호출을 사용하며 하향식으로 문제의 해결 방법을 정의
- 종료 조건은 제일 밑바닥에 도달했는지를 확인.  
- 제일 위에서 문제를 풀기 시작하여 문제 해결에 필요한 제일 밑바닥까지 하위문제를 푼다.

```javascript
function factorial(n) {
  if(n < 1) return 1;
  return n * factorial(n-1);
}
```

​      

#### 상향식 접근 방법

- 상향식 접근 방법은 밑바닥에서부터 풀이법을 전개해나간다.

```javascript
function factorial(n) {
  let result = 1;
  for(let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}
```

​      

#### 접근 방식의 차이

- 하향식 접근 방법 : 먼저 목적지를 인식하고 거기에 도달하기 위한 수단을 강구한다.
- 상향식 접근법 : 사용 가능한 모든 수단을 확보한 후 목적지로 이동한다.

​       

### 예제 : 이진 트리

- 하향식 접근법의 가장 간단한 예제는 이진 트리 알고리즘이다. 

- 주어진 이진 트리에 대해서 각 노드 자신을 포함한 하위 노드의 값의 합을 구해본다.

- 트리의 루트를 시작점으로 하여 왼쪽 자식 트리와 오른쪽 자식 트리의 문제가 이미 해결되었다고 가정하고 양쪽 자식 트리의 결과를 루트 트리에 취합하여 계산만 하면 된다.

```
종료조건
1. 현재의 노드가 NULL이면 아무것도 하지 않는다.
2. 현재 노드가 종단 노드이면 아무것도 하지 않는다.
```

​       

여기서는 자식 노드의 트리에 대한 계산이 끝난 다음에 더해야 하므로 후위 순회로 탐색한다.

```
root의 자식 노드들의 합
	root의 왼쪽 서브 트리들의 합
	root의 오른쪽 서브 트리들의 합
	두 서브 트리의 합과 root 노드의 값을 더한다.
```

​    

#### 코드 구현

```javascript
addChildSum(root) {
  if(!root) return 0;
  
  root.value += addChildSum(root.left);
  root.value += addChildSum(root.right);
  
  return root.value;
}
```

> 재귀 호출을 사용하는 방식은 하향식 문제 풀이 방식이다. 
> 메모 전략 역시 하향식 방식이지만 캐시후 재활용하기에 개선된 방법이다.
>
> 다이내믹 프로그래밍은 재귀 호출 자체로부터 발생하는 부하를 피하기 위해서 상향식으로 문제를 해결한다.





### 상향식 다이내믹 프로그래밍이 좋지 않은 경우

- 하향식 접근 방법(재귀호출, 메모전략) 에서는 모든 하위 문제를 풀지 않고 필요한 하위문제만 푼다. 

- 상향식 다이내믹 프로그래밍에서는 모든 하위 문제에 대해서 계산을 수행한다.
- 불필요한 하위 문제 풀이를 피하기 위해 문제 풀이 구조를 적절하기 구성해야 할때가 있다.

​       

#### 조합 점화식

예시로 수학에서 조합(combination)은 다음과 같은 점화식으로 정의할 수 있다.

```
C(n, m) = C(n-1, m) + C(n-1, m-1)
```

```javascript
function combination(n, m) {
  if(n === 0 || m === 0 || n === m) return 1;
  return combination(n-1, m) + combination(n-1, m-1);
}
```

​      

#### 조합 다이내믹 프로그래밍

이 문제를 다이내믹 프로그래밍으로 푸는 방법은 전체 파스칼 삼각형을 구상한 다음 N=1번째 행의 M=1번째 값을 반환하면 된다.

```
          1
        1   1
      1   2   1
    1   3   3   1
  1   4   6   4   1
1   5  10  10  [5]  1

C(5, 4) = 5
```

다이내믹 프로그래밍 해법에서는 전체 삼각형을 구성한 후 이 값을 반환한다. 하지만 재귀 호출을 사용하는 경우는 필요한 노드의 값만 계산한다.

```
          1
       [1] [1]
      1  [2] [1]
    1   3  [3] [1]
  1   4   6  [4] [1]
1   5  10  10  [5]  1
```

따라서 n과 m이 매우 큰 값이라면 재귀 해법은 이 문제에서는 시간과 메모리 양 측면에서 다이내믹 프로그래밍보다 좋은 성능을 보일 것이다.









































