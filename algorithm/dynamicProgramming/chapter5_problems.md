# 5장 실전 문제

## 5.1 최소 교정 비용 문제

두 단어 str1, str2가 주어지고 str1에서 수행할 수 있는 연산은 삽입, 삭제, 치환이 있다. 두 단어 간의 교정 비용은 한 단어에서 다른 단어로 바꾸는데 필요한 글자 연산 횟수로 정의한다. str1 -> str2로 바꾸는데 필요한 연산의 최소 개수를 구하는 프로그램을 작성해보자.

```
C A T
    |
C A R
    치환
    
=>최소 교정 비용 : 1

S     U N D A Y
  | |   |
S A T U R D A Y
 삽입삽입  치환
 
=> 최소 교정 비용  : 3
```

​     

### 재귀 호출을 사용하는 풀이와 설명

재귀로 풀기 위해서 같은 유형을 가진 작은 문제를 사용해 큰 문제를 정의할 수 있어야 한다.

str1, str2의 각 첫번째 글자가 시작지점이다.

1. 두 글자가 같다면 양쪽 단어의 첫 번째 글자에 대해서는 아무것도 하지 않아도 되며, 첫 글자를 제외한 두 단어 간의 최소 교정비용을 찾아야 한다. 즉 양쪽 단어에서 첫 번째 글자는 무시한다는 의미이다.
2. 두 글자가 다르다면 사용 가능한 세 개의 연산을 그려해봐야 한다.
   1. 삭제 연산: str1에서 첫 번째 글자를 삭제하고 난 후의 첫 번째 글자가 삭제된 str1과 str2사이의 최소교정 비용을 구한다.
   2. 치환 연산 : str1의 첫 번째 글자를 ㄴtr2의 첫번째 글자로 치환한 다음 양쪽의 첫 번째 글자를 제외한 단어 간의 최소 교정 비용을 구한다.
   3. 삽입 연산 : str2의 첫 번째 글자를 ,str1이제일 앞에 삽입한 다음 양쪽 단어의 첫 번째 글자를 제외한 나머지 단어 간의 최소 교정 비용을 구한다. 그리고 str1의 길이는 한 글자 증가한다.

연산 이후의 최소 교정 비용은 재귀 호출에 맡기낟. 삭제, 치환, 삽입의 어떤 연산을 수행하건 하나의 연산을 수행하므로 각 재귀 호출의 결과 중 제일 최소값에 1을 더해서 반환한다. 이 코드는 O(3^n)의 시간 복잡도를 갖는다. 

```typescript
// 책 원문은 포인터로 연산하지만 js에서는 그러지 않으니 인덱스값을 받아서 한다.
// slice를 써도 되겠지만 그러면 문자열 복사가 계속해서 일어나지 효율적이지 못하다.

export function editDistance(str1: string, str2: string) {
  function calculate(idx1: number, idx2: number): number {
    // str1이 빈 문자열이면 str2의 모든 글자를 삽입하면 된다.
    if (str1.length <= idx1) return str2.length - idx2;

    // str2이 빈 문자열이면 str1의 모든 글자를 제거하면 된다.
    if (str2.length <= idx2) return str1.length - idx2;

    // 첫번째 글자가 같을 때는 첫 번째 글자를 무시하고 나머지 단어 간의 최소 교정 비용ㅇ르 구한다.
    if (str1[idx1] === str2[idx2]) return calculate(idx1 + 1, idx2 + 1);

    // 삭제 연산
    const remove: number = calculate(idx1 + 1, idx2);

    // 치환 연산
    const update: number = calculate(idx1 + 1, idx2 + 1);

    // 삽입 연산
    const insert: number = calculate(idx1, idx2 + 1);

    // 세 연산 이후 최소 교정 비용 간의 최소값에 1을 더해서 반환한다.
    return getMinimum(remove, update, insert) + 1;
  }
  return calculate(0, 0);
}

function getMinimum(...args: number[]): number {
  return args.reduce((p, a) => Math.min(p, a));
}

```



​             

### 다이나믹 프로그래밍을 사용하는 풀이와 설명

다이나믹 프로그래밍 접근 방법은 두 단어의 교정 비용을 구하는 과정에 필요한 모든 가능한 조합에 대해서 교정 비용을 상향식으로 구해보는 것이다. str1, str2 두 단어의 길이가 각각 n과 m이라면 빈 문자열의 경우를 포함한 모든 가능한 조합은 (m+1) x (n + 1) 크기의 행렬을 사용해야 한다.

|      |      |  S   |  A   |  T   |  U   |  R   |  D   |  A   |  Y   |
| :--: | ---- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |      |      |      |      |      |      |      |      |      |
|  S   |      |      |      |      |      |      |      |      |      |
|  U   |      |      |      |      |      |      |      |      |      |
|  N   |      |      |      |      |      |      |      |      |      |
|  D   |      |      |      |      |      |      |      |      |      |
|  A   |      |      |      |      |      |      |      |      |      |
|  Y   |      |      |      |      |      |      |      |      |      |

이 행렬의 \(i, j\) 번째 셀의 값은 str1의 i개의 글자와 str2의 j개의 글자 사이의 최소 교정 비용의 값이다. 이 행렬의 값을 모두 채우고 난 후의 가장 우하단의 값 C\(7,8\) 이 두 문자간의 최소 교정 비용이 된다.

위 행렬에서 첫 번째 행은 첫 번째 단어가 빈 문자열일 때의 최소 교정 비용이며, 첫 번째 열은 두 번째 단어가 빈 문자열일 때의 최소 교정 비용이다.

첫 번째 열과 첫 번째 행은 쉽게 채울 수 잇다. 첫 번째 단어가 빈 문자열일 때 두 단어를 똑같이 만들려면 두 번째의 단어의 모든 글자를 첫 번째 단어에 삽입하거나 두 번째 단어의 모든 글자를 삭제하면 된다. 어떤 쪽이건 필요한 연산의 수는 두 번째 단어의 글자수와 같다. 비슷한 방식으로 첫 번째 열도 첫 번째 단어의 글자의 수로 채울 수 있다.


|      |      |  S   |  A   |  T   |  U   |  R   |  D   |  A   |  Y   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
|  S   |  1   |      |      |      |      |      |      |      |      |
|  U   |  2   |      |      |      |      |      |      |      |      |
|  N   |  3   |      |      |      |      |      |      |      |      |
|  D   |  4   |      |      |      |      |      |      |      |      |
|  A   |  5   |      |      |      |      |      |      |      |      |
|  Y   |  6   |      |      |      |      |      |      |      |      |

나머지 셀은 다음 로직에서 채울 수 있다. 여기서 EditD가 앞에서 본 표에 해당하는 배열, 즉 최소 교정 비용을 저장하는 배열이다.

```
if(str[i-1] === str[j-1])
	EditD[i][j] = EditD[i-1][j-1]
else
	EditD[i][j] = 1 + MINIMUM(EditD[i-1][j-1], EditD[i-1][j], EditD[i][j-1])
```

1. 두 글자가 같으면 교정 비용의 차이가 없으므로 대각선 방향 왼쪽 위 셀의 값을 가지고 온다. 

2. 두 글자가 다르면 위쪽 셀, 왼쪽 셀, 왼쪽 위 셀의 값의 최솟값을 가져와 1을 더한다. 각 셀에 해당하는 문자열에 치환, 삽입, 삭제 연산을 통해서 도달한 결과이다. 

   1. str1에 삭제 연산을 수행하면 sun, satur의 최소 교정 비용과 같은 값이 된다.
   2. str1에 삽입 연산을 수행하면 sundr, satur이 되어 sund , satu의 최소 교정 비용과 같은 값이 된다.
   3. 양쪽 단어에 최환 연산을 수행하면 sun, satu의 최소 교정 비용과 같은 값이 된다.

```typescript
function editDistance(str1: string, str2: string, m: number, n: number) {
  const EditD = Array(m + 1)
    .fill(0)
    .map((o: number) => Array(n + 1).fill(0));

  for (let j = 0; j <= n; j++) EditD[0][j] = j;

  for (let i = 0; i <= m; i++) EditD[i][0] = i;

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      // 두 글자가 같다면
      if (str1[i - 1] == str2[j - 1]) EditD[i][j] = EditD[i - 1][j - 1];
      // 두 글자가 다르다면
      else
        EditD[i][j] =
          getMinimum(EditD[i - 1][j - 1], EditD[i][j - 1], EditD[i - 1][j]) + 1;
    }
  }
  return EditD[m][n];
}
```

이 로직을 따라 다음과 같이 행렬이 채워진다.

|      |      |  S   |  A   |  T   |  U   |  R   |  D   |  A   |  Y   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
|  S   |  1   |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
|  U   |  2   |  1   |  1   |  2   |  2   |  3   |  4   |  5   |  6   |
|  N   |  3   |  2   |  2   |  2   |  3   |  3   |  4   |  5   |  6   |
|  D   |  4   |  3   |  3   |  3   |  3   |  4   |  3   |  4   |  5   |
|  A   |  5   |  4   |  3   |  4   |  4   |  4   |  4   |  3   |  4   |
|  Y   |  6   |  5   |  4   |  4   |  5   |  5   |  5   |  4   |  3   |

이 코드의 시간 복잡도는 O(n^2)이며 O(n^2)만큼의 추가메모리가 필요하다.






​          

## 5.2 직사각형에서 총 경로 수 구하기

### 재귀 호출을 사용하는 풀이와 설명



### 다이나믹 프로그래밍을 사용하는 풀이와 설명



​      

## 5.3 문자열 인터리빙 확인 문제

### 재귀 호출을 사용하는 풀이와 설명



### 다이나믹 프로그래밍을 사용하는 풀이와 설명



